{"name":"Aura","tagline":"Aura Library for .NET -- Extends the MongoDB .NET driver to make your life easier","body":"# Aura Project\r\nWelcome! Aura is a very simple wrapper library for 10gen's [Official MongoDB C#/.NET Driver](http://www.mongodb.org/display/DOCS/CSharp+Language+Center) that helps shortcut some repetitive tasks when building applications that use MongoDB to store documents in strongly-typed collections.\r\n\r\n## Quick Start\r\nThe easiest way to get started with Aura is to\r\n\r\n1. Checkout Aura (builds will be available soon!) and build it\r\n2. Ad Aura as a dependency\r\n3. Have a mongodb:// connection string in your connectionStrings\r\n```\r\n<connectionStrings>\r\n    <add key=\"MyCoolMongoDatabase\" value=\"mongodb://hostname/database\" /> \r\n</connectionStrings>\r\n```\r\n3. Create the classes that you wish to store and retrieve with MongoDB.  This can be done of two ways:\r\n    * Create your own POCO classes and add the [BsonId] attribute to your uniquely identifying field if it isn't  called Id, id, or _id.\r\n```\r\npublic class Person {\r\n    [BsonId]\r\n    public Guid PersonId { get; set; }\r\n    public string Name { get; set; }\r\n}\r\n```\r\n    * Inherit from **_Aura.Record_** or **_Aura.TimestampedRecord_** which already has an Id with an associated autogenerator\r\n```\r\n[BsonId(IdGenerator = typeof(StringObjectIdGenerator))]\r\npublic virtual string Id { get; set; }\r\n```\r\n\r\nNow you can create an instance of **RecordManager\\<Person\\>** and go to town.  For example:\r\n\r\n```\r\n    var personManager = new RecordManager<Person>();\r\n    Person person = personManager.GetById(person.Id);\r\n    person.Name = \"Updated Name\";\r\n    personManager.Save(person);\r\n```\r\n\r\n## What Aura _does not_ do\r\n\r\nAura does not promise to take out your trash or walk you dog. If it improves your marriage, then it's probably just because it saved you a few extra minutes at work. \r\n\r\nEverything that can be done with Aura can be done directly using the 10Gen Driver.  Aura simply wraps some of the common operations I found myself repeating and makes some of those repetitive tasks a little bit less... repetitive... :) \r\n\r\nAura also provides some _very limited_ prescriptive guidance when starting up a new project using MongoDB. \r\n\r\n## What Aura _does_ do\r\n\r\nAura provides a few features on top of the MongoDB driver, all of which can be used independently of each other.  Feel free to use the features you want and ignore the rest, Aura won't get it's feelings hurt.\r\n\r\nFeatures offered by Aura:\r\n\r\n* A simple [Repository Pattern](http://martinfowler.com/eaaCatalog/repository.html) wrapper for MongoDB collections exposing the most common CRUD functionality for strongly typed documents \r\n\r\n```\r\ninternal class PersonManager : RecordManager<Person> {\r\n    // Public methods inherited from RecordManager<T>\r\n    IQueryable<T> AsQueryable { get; }\r\n    void DeleteById(object id);\r\n    T GetById(object id);\r\n    IEnumerable<T> GetManyByIds(IEnumerable<object> ids);\r\n    bool Save(T record);\r\n    void BatchInsert(IEnumerable<T> records);\r\n\r\n    // Protected methods inherited from RecordManager<T>\r\n    long Count(IMongoQuery criteria = null);\r\n    IEnumerable<T> Find(IMongoQuery criteria, IMongoSortBy sort = null, int? skip = null, int? limit = null);\r\n    T FindSingle(IMongoQuery criteria);\r\n    void Initialize(); // For once-per application runtime maintenance like Ensuring Indexes, Purging Data, Setting Conventions\r\n    void DropCollection();\r\n    T FindOneAndModify(IMongoQuery criteria, IMongoUpdate update, IMongoSortBy sortBy = null, bool returnModifiedVersion = true);\r\n    T FindOneAndRemove(IMongoQuery criteria, IMongoSortBy sortBy = null);\r\n    IEnumerable<T> EnumerateAndModify(IMongoQuery criteria, IMongoUpdate update, IMongoSortBy sortBy = null, bool returnModifiedVersion = true);\r\n    IEnumerable<T> EnumerateAndRemove(IMongoQuery criteria, IMongoSortBy sortBy = null);\r\n    long UpdateMany(IMongoQuery criteria, UpdateBuilder update, bool asUpsert = false);\r\n    long DeleteMany(IMongoQuery criteria);\r\n    void EnsureIndex(IMongoIndexKeys keys, IMongoIndexOptions options);\r\n}\r\n```\r\n* Lambda-based property-name resolution for building MongoDB queries without using magic strings \r\n\r\n```\r\npublic IEnumerable<Person> GetByLastName(string LastName) {\r\n  // Instead of magic strings like this:\r\n  return Find(Query.EQ(\"LastName\", LastName));\r\n  // Use Lambdas for Compile-time safety like this:\r\n  return Find(Query.EQ(PropertyName(p => p.LastName), LastName));\r\n  // Also works for collection members by using .Member()\r\n  string ChildLastNameField = PropertyName(p.Children.Member().LastName; // Evaluates to \"Children.LastName\"\r\n  return Find(Query.EQ(LastNameField, LastName)); // [NOTE: Returns the parent document]\r\n  // You can find the relative properties on a child object (without the parent prefix) using .Relative(), useful for $elemMatch\r\n  string LastNameField = PropertyName(p.Children.Relative().LastName; // Evaluates to \"LastName\" (without the \"Children.\")\r\n}\r\n```\r\n\r\n* Simple connection-string configuration using native .NET operations. Users with a single mongodb:// connection string just work!\r\n\r\n```\r\n<connectionStrings>\r\n    <add key=\"MyCoolMongoDatabase\" value=\"mongodb://hostname/database\" /> \r\n</connectionStrings>\r\n```\r\n\r\n* A base-class from which strongly-typed documents can optionally inherit, providing string-typed Ids and automatic **_id** field population if saved as **null**.\r\n\r\n```\r\npublic class Person : Record {\r\n  public string FirstName { get; set; }\r\n  public string LastName { get; set; }\r\n  public Address Address { get; set; }\r\n  public Person[] Children { get; set; }\r\n}\r\n\r\n// Inherited from Record\r\n[BsonId(IdGenerator = typeof(StringObjectIdGenerator))]\r\npublic virtual string Id { get; set; }\r\n```\r\n\r\n* Another base-class (and interface) from which documents can inherit providing automatic maintenance of Creation/Modification timestamps.\r\n\r\n```\r\npublic class Person : ITimeStampedRecord {\r\n  #region ITimeStampedRecord Members\r\n  public DateTime CreatedDate { get; set; }\r\n  public DateTime ModifiedDate { get; set; }\r\n  #endregion\r\n}\r\n```\r\n\r\n* A caching record manager to cache (by Id) retrieved instances of objects (useful for lookup collections)\r\n\r\n* A set of convenience methods for interacting with MongoDB's new Aggregation Framework.\r\n\r\n```\r\n... class ... : RecordManager {\r\n\r\npublic Dictionary<string,int> CalculateVerseCountByBook() {\r\n  return base.Aggregate(\r\n\t\t\tAggregation.Group(\r\n\t\t\t\tAggregation.Grouping.By(PropertyName(x => x.Book)), \r\n\t\t\t\tAggregation.Grouping.Count(\"Count\")),\r\n\t\t\tAggregation.Sort(Aggregation.Sorting.By(\"Count\", false))\r\n\t).ToDictionary(x => x[ID_FIELD].AsString, x => x[\"Count\"].AsInt32);\r\n}\r\n```\r\n\r\n## Giving credit where credit is due\r\n\r\nThis project would not be possible without the amazing work done by Phillip Markert for Mongol. This project is\r\nderived from Mongol, with a few major infrastructure changes to make my life easier with it:\r\n\r\n* Using native .NET connection strings instead of appSettings\r\n* A DatabaseManager class that automatically creates RecordManager instances using the proper connection settings (inspired by EntityFramework) and schema migration (deleting non-requested indexes and provides easy way to remove deleted fields from project)\r\n* Modernized against modern MongoDB C# driver\r\n* Using log4net instead of Common logger\r\n* Integration with IoC containers (when using DatabaseManager) -- DatabaseManager uses CommonServiceLocator to retreive RecordManager types for integration with your IoC container\r\n","note":"Don't delete this file! It's used internally to help with page regeneration.","google":""}